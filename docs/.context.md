# LinkedIn Clone Application - AI Assistant Context

**Last Updated**: November 1, 2024  
**Version**: 1.0  
**Purpose**: Context document for AI assistants working on this project

## 🎯 Your Role

You are an AI assistant helping with a full-stack LinkedIn clone application. This document provides you with essential context about the project structure, architecture, conventions, and patterns to help you provide accurate and consistent assistance.

## 🏗️ Project Architecture Overview

### System Architecture
This is a **microservices-based application** with:
- **Frontend**: React 18+ with Vite, Tailwind CSS, Redux Toolkit
- **Backend**: Spring Boot 3.x microservices with Spring Cloud
- **Event Bus**: Apache Kafka for asynchronous communication
- **Databases**: PostgreSQL (relational), Neo4j (graph database for connections)
- **Infrastructure**: Kubernetes (GKE), Docker, Docker Compose

### Service Communication Flow
```
Client (React) 
    → API Gateway (Port 8080) 
        → Eureka Service Discovery (Port 8761)
            → Microservices:
                - Users Service (Port 9010) + PostgreSQL
                - Posts Service (Port 9020) + PostgreSQL
                - Connections Service (Port 9030) + Neo4j
                - Notification Service (Port 9040) + PostgreSQL
            → Kafka Event Bus (async communication)
```

## 🔧 Microservices Details

### 1. API Gateway (Port 8080)
- **Technology**: Spring Cloud Gateway
- **Context Path**: Base path `/api/v1`
- **Responsibilities**:
  - Single entry point for all client requests
  - JWT authentication validation
  - Request routing to microservices
  - Load balancing
- **Key Configuration**: Routes defined in `application.yml`
- **When helping**: Always reference gateway paths for client-facing APIs

### 2. Discovery Server (Port 8761)
- **Technology**: Netflix Eureka
- **Responsibilities**: Service registry and discovery
- **When helping**: Services auto-register; ensure `eureka.client` configuration is present

### 3. Config Server (Port 8888)
- **Technology**: Spring Cloud Config
- **Responsibilities**: Centralized configuration management
- **When helping**: Configuration externalization for different environments

### 4. Users Service (Port 9010)
- **Context Path**: `/users`
- **Database**: PostgreSQL (users-db)
- **Responsibilities**:
  - User registration and authentication
  - JWT token generation and validation
  - User profile management
- **Key Endpoints**:
  - `POST /auth/signup` - Public
  - `POST /auth/login` - Public
  - `GET /core/profile` - Requires JWT
- **When helping**: 
  - Password hashing uses BCrypt
  - JWT tokens contain userId claim
  - All `/core/**` endpoints require authentication

### 5. Posts Service (Port 9020)
- **Context Path**: `/posts`
- **Database**: PostgreSQL (posts-db)
- **Responsibilities**:
  - Post CRUD operations
  - Like/unlike functionality
  - Feed generation
- **Kafka Events Published**:
  - `post-created-topic`: { postId, authorId, content, timestamp }
  - `post-liked-topic`: { postId, likedByUserId, timestamp }
- **Key Endpoints**:
  - `POST /core` - Create post
  - `GET /core/{postId}` - Get post
  - `GET /core/users/allPosts` - Get user's posts
  - `POST /likes/{postId}/like` - Like post
  - `DELETE /likes/{postId}/unlike` - Unlike post
- **When helping**:
  - Post visibility: PUBLIC or CONNECTIONS
  - Like count is tracked in posts table
  - Events trigger notifications

### 6. Connections Service (Port 9030)
- **Context Path**: `/connections`
- **Database**: Neo4j (graph database)
- **Responsibilities**:
  - Connection request management
  - Network graph operations
  - Suggested connections algorithm
- **Neo4j Relationships**:
  - `CONNECTION_REQUESTED` - Pending request
  - `CONNECTED_TO` - Established connection
- **Kafka Events Published**:
  - `connection-request-sent-topic`: { fromUserId, toUserId, timestamp }
  - `connection-accepted-topic`: { fromUserId, toUserId, timestamp }
- **Key Endpoints**:
  - `GET /core/first-degree` - Get direct connections
  - `POST /core/request/{userId}` - Send request
  - `POST /core/accept/{userId}` - Accept request
  - `POST /core/reject/{userId}` - Reject request
  - `GET /core/suggested-connections` - Get suggestions
- **When helping**:
  - Uses Neo4j Cypher queries for graph operations
  - Person nodes: { id, name, email }
  - Suggested connections exclude already connected users

### 7. Notification Service (Port 9040)
- **Context Path**: `/notifications`
- **Database**: PostgreSQL (notification-db)
- **Responsibilities**:
  - **Event-driven**: Consumes Kafka events
  - Creates notifications for users
  - Notification retrieval
- **Kafka Topics Consumed**:
  - `post-created-topic`
  - `post-liked-topic`
  - `connection-request-sent-topic`
  - `connection-accepted-topic`
- **Key Endpoints**:
  - `GET /core/users/allNotifications` - Get latest 20 notifications
- **When helping**:
  - This is a Kafka consumer service
  - Notifications have types: POST_CREATED, POST_LIKED, CONNECTION_REQUEST, CONNECTION_ACCEPTED
  - Auto-creates notifications from events

## 🔐 Authentication & Security Patterns

### JWT Authentication Flow
1. User calls `POST /api/v1/users/auth/login` with credentials
2. Users Service validates and returns JWT token
3. Client includes token in header: `Authorization: Bearer <token>`
4. API Gateway validates JWT before routing
5. Services receive `X-User-Id` header from gateway

### Public vs Protected Endpoints
- **Public**: `/auth/signup`, `/auth/login`, `/actuator/health`
- **Protected**: All `/core/**` endpoints require valid JWT
- **When helping**: Always check if endpoint needs authentication

### Security Implementation
- Password hashing: BCrypt with Spring Security
- JWT generation: Uses Spring Security and JWT libraries
- Token expiration: Configured per environment
- API Gateway: Validates JWT via filter chain

## 📡 Event-Driven Architecture (Kafka)

### Kafka Configuration
- **Internal Bootstrap**: `kafka:29092` (within Kubernetes/Docker)
- **External Bootstrap**: `localhost:9092` (for local tools)
- **Consumer Groups**: Each service has dedicated groups

### Event Flow Pattern
1. **Producer Service**: Performs action (create post, send request)
2. **Producer Service**: Publishes event to Kafka topic
3. **Kafka**: Stores and distributes event
4. **Consumer Service** (Notification): Receives event
5. **Consumer Service**: Creates notification in database

### When Helping with Events
- Always include timestamp in event payload
- Use try-catch for Kafka operations
- Log event publishing/consumption
- Events are asynchronous - don't expect immediate feedback
- Consumer idempotency is important

## 🗄️ Database Schemas

### Users Database (PostgreSQL)
```sql
users: id, name, email, password_hash, created_at, updated_at
```

### Posts Database (PostgreSQL)
```sql
posts: id, author_id, content, visibility, like_count, created_at
post_likes: id, post_id, user_id, created_at
```

### Connections Database (Neo4j)
```cypher
(:Person {id, name, email})-[:CONNECTION_REQUESTED|CONNECTED_TO]->(:Person)
```

### Notifications Database (PostgreSQL)
```sql
notifications: id, user_id, type, reference_id, message, read, created_at
```

## 📁 Repository Structure

```
linkedin-app/
├── backend/
│   ├── api-gateway/           # Spring Cloud Gateway
│   ├── config-server/         # Spring Cloud Config
│   ├── discovery-server/      # Eureka Server
│   ├── users-service/         # User management + auth
│   ├── posts-service/         # Posts + likes
│   ├── connections-service/   # Network graph (Neo4j)
│   ├── notification-service/  # Event consumer
│   └── .context.md           # Backend-specific context
├── frontend/
│   ├── src/
│   │   ├── components/       # React components
│   │   ├── pages/           # Page components
│   │   ├── services/        # API calls (axios)
│   │   ├── redux/           # State management
│   │   └── utils/           # Utilities
│   ├── README.md
│   └── [other config files]
├── infrastructure/
│   ├── docker/
│   │   └── docker-compose.yml  # Local development
│   ├── k8s/                    # Kubernetes manifests
│   └── .context.md             # Infrastructure context
├── docs/
│   ├── CONTEXT.md             # This file (for AI assistants)
│   ├── README.md              # API reference (for developers)
│   ├── FOLDER_STRUCTURE.md    # Project structure
│   ├── api/                   # API documentation
│   ├── architecture/          # Architecture diagrams
│   └── deployment/            # Deployment guides
└── .ai-instructions.md        # AI update guidelines
```

## 🔨 Development Patterns & Conventions

### Backend (Spring Boot)

#### Project Structure per Service
```
service-name/
├── src/main/java/com/linkedin/{service}/
│   ├── controller/        # REST endpoints (@RestController)
│   ├── service/          # Business logic (@Service)
│   ├── repository/       # Data access (@Repository, JPA/Neo4j)
│   ├── model/            # JPA entities (@Entity)
│   ├── dto/              # Data Transfer Objects
│   ├── mapper/           # Entity ↔ DTO converters
│   ├── exception/        # Custom exceptions
│   ├── config/           # Configuration classes
│   └── kafka/
│       ├── producer/     # Kafka producers
│       └── consumer/     # Kafka consumers
└── src/main/resources/
    ├── application.yml   # Spring configuration
    └── application-prod.yml
```

#### Coding Conventions
- **Controllers**: Use `@RestController`, return `ResponseEntity<T>`
- **Services**: Business logic in `@Service` classes
- **Repositories**: Extend `JpaRepository` or `Neo4jRepository`
- **DTOs**: Use for API requests/responses, not entities
- **Mappers**: Convert between entities and DTOs
- **Exception Handling**: Use `@ControllerAdvice` for global handling
- **Validation**: Use Jakarta Bean Validation (`@Valid`, `@NotNull`, etc.)
- **Logging**: Use SLF4J: `private static final Logger log = LoggerFactory.getLogger()`

#### Dependencies (Maven)
- Spring Boot Starter Web
- Spring Boot Starter Data JPA (for PostgreSQL services)
- Spring Boot Starter Data Neo4j (for Connections Service)
- Spring Cloud Netflix Eureka Client
- Spring Kafka
- Spring Security
- JWT libraries (jjwt)
- PostgreSQL Driver / Neo4j Java Driver

### Frontend (React)

#### Component Structure
- **Functional Components**: Use hooks (useState, useEffect, etc.)
- **Redux**: Use Redux Toolkit slices
- **API Calls**: Centralized in `services/` folder
- **Styling**: Tailwind CSS utility classes
- **Routing**: React Router v6

#### File Naming
- Components: PascalCase (e.g., `UserProfile.jsx`)
- Services: camelCase (e.g., `userService.js`)
- Utils: camelCase (e.g., `formatDate.js`)

#### API Service Pattern
```javascript
// services/userService.js
import axios from 'axios';
const API_BASE = import.meta.env.VITE_API_URL;

export const login = async (credentials) => {
  const response = await axios.post(`${API_BASE}/users/auth/login`, credentials);
  return response.data;
};
```

### Infrastructure

#### Docker Compose (Local Development)
- All services defined in `infrastructure/docker/docker-compose.yml`
- Services, databases, Kafka, Zookeeper all containerized
- Port mappings for external access

#### Kubernetes (GKE Production)
- Manifests in `infrastructure/k8s/`
- Each service has: Deployment, Service, ConfigMap
- Databases: StatefulSets with PersistentVolumeClaims
- API Gateway: LoadBalancer service for external access
- Others: ClusterIP for internal communication

## 🎯 When Helping with Specific Tasks

### Adding New API Endpoint
1. Create controller method with appropriate mapping
2. Implement service layer logic
3. Add/update repository methods if needed
4. Create/update DTOs
5. Add validation annotations
6. Update API Gateway routes if needed
7. Document in docs/README.md
8. Test the endpoint

### Adding New Kafka Event
1. Define event payload structure (DTO)
2. Create Kafka producer in publishing service
3. Publish event after business logic
4. Create/update Kafka consumer in Notification Service
5. Handle event and create notification
6. Add error handling and logging
7. Document event in docs

### Adding New Microservice
1. Create new module in backend/
2. Add Spring Boot dependencies in pom.xml
3. Configure Eureka client
4. Configure database connection
5. Implement business logic
6. Add Dockerfile
7. Create Kubernetes manifests
8. Update API Gateway routes
9. Update documentation

### Frontend Feature Development
1. Create component in appropriate folder
2. Add Redux slice if state needed
3. Create API service methods
4. Implement component with Tailwind CSS
5. Add routing if needed
6. Handle loading and error states
7. Test with backend API

### Database Migrations
- Use JPA `ddl-auto=update` for development
- For production: Consider Flyway or Liquibase
- Create migration scripts in `resources/db/migration/`

## 🐛 Common Issues & Solutions

### Service Discovery Issues
- **Problem**: Services can't find each other
- **Solution**: Check Eureka registration, verify `spring.application.name`, check network connectivity

### Kafka Connection Issues
- **Problem**: Can't connect to Kafka
- **Solution**: Verify bootstrap servers config, check if Kafka is running, verify network access

### JWT Authentication Issues
- **Problem**: 401 Unauthorized errors
- **Solution**: Check token format, verify token not expired, check API Gateway JWT filter

### Neo4j Connection Issues
- **Problem**: Connection Service can't connect to Neo4j
- **Solution**: Verify Bolt URI (bolt://localhost:7687), check credentials, verify Neo4j is running

### CORS Issues (Frontend)
- **Problem**: Browser blocking API calls
- **Solution**: Configure CORS in API Gateway, check allowed origins

## 📊 Performance Considerations

- **Database Queries**: Use pagination for list endpoints
- **Caching**: Consider Redis for frequently accessed data (future enhancement)
- **Kafka**: Batch operations where possible
- **API Gateway**: Implement rate limiting (future enhancement)
- **Frontend**: Use React.memo, useMemo, useCallback for optimization

## 🧪 Testing Guidelines

### Backend Testing
- **Unit Tests**: Test service layer logic with Mockito
- **Integration Tests**: Test controllers with MockMvc
- **Repository Tests**: Use `@DataJpaTest` or `@DataNeo4jTest`
- **Kafka Tests**: Use EmbeddedKafka

### Frontend Testing
- **Component Tests**: React Testing Library
- **Redux Tests**: Test reducers and selectors
- **API Mock**: Use MSW (Mock Service Worker)

## 🚀 Deployment Knowledge

### Local Development
```bash
# Start all services
cd infrastructure/docker
docker-compose up -d

# Access services
API Gateway: http://localhost:8080
Eureka Dashboard: http://localhost:8761
```

### Kubernetes Deployment
```bash
# Apply all manifests
kubectl apply -f infrastructure/k8s/

# Check deployments
kubectl get pods
kubectl get services

# View logs
kubectl logs <pod-name>
```

## 📝 Documentation Standards

### Code Comments
- Comment complex business logic
- Document public API methods
- Explain non-obvious decisions
- Don't comment obvious code

### API Documentation
- Update docs/README.md for API changes
- Include request/response examples
- Document authentication requirements
- List all endpoints with descriptions

### Commit Messages
- Format: `type(scope): description`
- Types: feat, fix, docs, refactor, test, chore
- Example: `feat(posts): add like functionality`

## ⚠️ Important Reminders

1. **Never commit secrets**: Use environment variables, ConfigMaps, Secrets
2. **Always validate input**: Use Jakarta Bean Validation
3. **Handle errors gracefully**: Return appropriate HTTP status codes
4. **Log important events**: Use structured logging
5. **Test before commit**: Run tests locally
6. **Update documentation**: Keep docs in sync with code
7. **Follow REST conventions**: Use proper HTTP methods and status codes
8. **Secure endpoints**: Default to authenticated unless explicitly public
9. **Use DTOs**: Never expose entities directly in APIs
10. **Think event-driven**: Consider if action should publish event

## 🔄 This is a Living Document

- Update this file when architecture changes
- Add new patterns as they emerge
- Document gotchas and solutions
- Keep technology versions current
- Review and refine regularly

---

**For AI Assistants**: Use this context to provide accurate, consistent help. When unsure, ask for clarification. Always consider the full architecture when suggesting changes.
